## 算法与函数

算法M是求解一个特定问题的有限个良好定义的相继步骤的列表。

通常可以有不止一种方法求$f(X)$。获得$f(X)$的算法$M$的选择依赖于算法的“效率”和“复杂性”。

## 算法的复杂性

算法的复杂性是算法效率的衡量标准。

假设 $M$ 是一种算法，并设 $n$ 为输入数据的规模。实施$M$所占用的时间和空间是衡量该算法之效率的两个主要指标。
时间由“键盘操作”次数衡量。

比如：

    1. 对于排序和查找，对 比较次数 计数
    2. 在计算中，对乘法计数而忽略加法

键盘操作的定义前提是其他操作时间大大小于或 最多与键盘操作时间成比例。
空间由实施该算法所需的最大内存来衡量。

算法 M 的复杂性是一个函数 $f(n)$，它对于输入数据的规模$n$给出运行该算法所需时间与所需存储空间。
执行一个算法所需存储空间通常就是数据规模的倍数。
因此，除非特殊情况，“复杂性”将指运行算法的时间。

求 复杂性函数$f(n)$ 在复杂性理论中研究最多的两种情况是：

>1. 最坏情况 对于任何可能的输入，$f(n)$的最大值
>2. 平均情况 $f(n)$的期望值

### 线性查找

给定一个包含n个元素的线性数组DATA，和一个特定的信息ITEM，
在数组DATA中求出ITEM的位置LOC，或者传送某个信息，比如LOC = 0 表示ITEM不出现DATA中。
线性查找算法解决这个问题的途径是将ITEM与DATA中的元素一个一个地进行比较，直到求出LOC为止。

线性查找算法的复杂性由ITEM与DATA[K]之间的比较数字C给出。
C(n)的最坏情况和平均情况如下：

1. **最坏情况** C(n) = n；
  
2. **平均情况** C(n) = (n + 1) / 2

### 增长率与大O记号

假定M是一个算法，并设n为输入数据的大小，显示M的复杂性f(n)随着n的增长而增长。通常我们需要考察的是f(n)的增长率。
常常由f(n)与某标准函数相比较而得。假如：
$$
\log_{2} n, n, n \log_{2} n, n^2, n^3, 2^n
$$

等等，都可被用作为标准函数。
（对数函数 $\log_2 n$ 增长最慢，而指数函数 $2^n$ 增长最快）

**定义** 设f(x)与g(x)为定义于R或者R的子集上的任意两个函数，我们说“$f(x)$是$O(g(x))$的”，记作：
$$
f(x) = O(g(x))\quad \text{or} \quad f(x) \in O(g(x))
$$

如果存在字数 k 和正常如C使得对于所有的$x > k$有：

$$
|f(x)| \leq C|g(x)|
$$

同样地，当$f(x) - h(x) = O(g(x))$时，记：

$$
f(x) = h(x) + O(g(x))
$$

假定 $f_1(x)$ 是 $O(g_1(x))$ 的,  $f_2(x)$ 是 $O(g_2(x))$ 的, 那么
$$
({f_1+f_2})(x)=O\left(\max \left(\left|g_{1}(x)\right|,\left|g_{2}(x)\right|\right)\right)
$$

$$
({f_1f_2})(x)=O(g_1(x)g_2(x))
$$

### 大 $\Omega$ 记号与大 $\Theta$ 记号

如果存在正常数 $C$ 和 $k$ 使得对于所有的$x > k$有：
$$
|f(x)| \leq C|g(x)|
$$
我们说"$f(x)$是$\Omega (g(x))$的".

如果存在正常数 $C_1$ 和 $C_2$ 及一个正实数 $k$:
$$
C_{1}|g(x)| \leqslant|f(x)| \leqslant C_{2}|g(x)|
$$
则称 "$f(x)$是$\Theta (g(x))$的" 或 "$f(x)$和 $g(x)$ 同阶".

### 常见算法的复杂性

计算机科学中一些著名的查找和排序算法的复杂性

  1. 线性查找：$O(n)$
  2. 二叉查找：$O(\log n)$
  3. 冒泡排序：$O(n^2)$
  4. 归并排序：$O(n \log n)$
